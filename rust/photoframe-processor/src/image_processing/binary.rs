use anyhow::Result;
use image::{Rgb, RgbImage};

/// Convert an RGB image to ESP32 binary format
/// 
/// This function converts RGB pixel data to the 8-bit format used by the ESP32 photo frame:
/// - 3 bits for red (values 0-7)
/// - 3 bits for green (values 0-7) 
/// - 2 bits for blue (values 0-3)
/// 
/// The format is: RRRGGGBB (8 bits total per pixel)
/// 
/// This matches the logic from bmp2cpp/src/main.rs:217-218:
/// ```rust
/// let color8 = ((color.r() / 32) << 5) + ((color.g() / 32) << 2) + (color.b() / 64);
/// ```
pub fn convert_to_esp32_binary(img: &RgbImage) -> Result<Vec<u8>> {
    let (width, height) = img.dimensions();
    let expected_size = (width * height) as usize;
    let mut binary_data = Vec::with_capacity(expected_size);

    for pixel in img.pixels() {
        let color8 = rgb_to_esp32_color(pixel);
        binary_data.push(color8);
    }

    if binary_data.len() != expected_size {
        return Err(anyhow::anyhow!(
            "Binary data size mismatch: expected {}, got {}",
            expected_size,
            binary_data.len()
        ));
    }

    Ok(binary_data)
}

/// Convert a single RGB pixel to ESP32 8-bit color format
/// 
/// The ESP32 uses a compressed color format:
/// - Red: 3 bits (0-7) - divide by 32 to get 3-bit value
/// - Green: 3 bits (0-7) - divide by 32 to get 3-bit value  
/// - Blue: 2 bits (0-3) - divide by 64 to get 2-bit value
/// 
/// Final format: RRRGGGBB
pub fn rgb_to_esp32_color(pixel: &Rgb<u8>) -> u8 {
    let r = pixel[0];
    let g = pixel[1];
    let b = pixel[2];

    // Convert 8-bit color channels to reduced bit depths
    let r3 = (r / 32) & 0x07; // 3 bits: 0-7
    let g3 = (g / 32) & 0x07; // 3 bits: 0-7  
    let b2 = (b / 64) & 0x03; // 2 bits: 0-3

    // Combine into 8-bit value: RRRGGGBB
    (r3 << 5) | (g3 << 2) | b2
}

/// Convert ESP32 8-bit color back to RGB (for validation/debugging)
/// 
/// This is the reverse operation of rgb_to_esp32_color()
/// Used primarily for testing and validation
#[allow(dead_code)]
pub fn esp32_color_to_rgb(color8: u8) -> [u8; 3] {
    // Extract components
    let r3 = (color8 >> 5) & 0x07; // 3 bits for red
    let g3 = (color8 >> 2) & 0x07; // 3 bits for green
    let b2 = color8 & 0x03;        // 2 bits for blue

    // Scale back to 8-bit values
    let r8 = r3 * (255 / 7); // Scale 3-bit to 8-bit
    let g8 = g3 * (255 / 7); // Scale 3-bit to 8-bit
    let b8 = b2 * (255 / 3); // Scale 2-bit to 8-bit

    [r8, g8, b8]
}

/// Validate that a binary file has the correct size for given dimensions
#[allow(dead_code)]
pub fn validate_binary_size(binary_data: &[u8], width: u32, height: u32) -> Result<()> {
    let expected_size = (width * height) as usize;
    let actual_size = binary_data.len();

    if actual_size != expected_size {
        return Err(anyhow::anyhow!(
            "Binary size mismatch for {}x{}: expected {} bytes, got {} bytes",
            width,
            height,
            expected_size,
            actual_size
        ));
    }

    Ok(())
}

/// Generate a C header file with the binary data as an array
/// 
/// This matches the OutputFormat::CArray functionality from bmp2cpp
#[allow(dead_code)]
pub fn generate_c_header(
    binary_data: &[u8],
    variable_name: &str,
    source_filename: &str,
    width: u32,
    height: u32,
) -> String {
    let header_guard = format!("_{}_H_", variable_name.to_uppercase());
    
    // Split data into rows for better readability
    let chunks: Vec<String> = binary_data
        .chunks(width as usize)
        .map(|chunk| {
            chunk
                .iter()
                .map(|b| format!("0x{:02X}", b))
                .collect::<Vec<String>>()
                .join(", ")
        })
        .collect();

    let pixel_data = chunks.join(",\n");

    format!(
        r#"
#ifndef {header_guard}
#define {header_guard}

// This file is automatically generated by photoframe-processor
// from the image file: {source_filename}
// Image dimensions: {width}x{height} pixels

#if defined(ESP8266) || defined(ESP32)
#include <pgmspace.h>
#else
#include <avr/pgmspace.h>
#endif

const unsigned char {variable_name}[{size}] PROGMEM = {{
{pixel_data}
}};

#endif"#,
        header_guard = header_guard,
        source_filename = source_filename,
        width = width,
        height = height,
        variable_name = variable_name,
        size = binary_data.len(),
        pixel_data = pixel_data
    )
}

/// Statistics about color usage in the binary data
#[allow(dead_code)]
#[derive(Debug)]
pub struct ColorStats {
    pub unique_colors: std::collections::HashMap<u8, u32>,
    pub total_pixels: usize,
    pub most_common_color: Option<(u8, u32)>,
}

impl ColorStats {
    #[allow(dead_code)]
    pub fn analyze(binary_data: &[u8]) -> Self {
        let mut color_counts = std::collections::HashMap::new();
        
        for &color in binary_data {
            *color_counts.entry(color).or_insert(0) += 1;
        }

        let most_common_color = color_counts
            .iter()
            .max_by_key(|(_, &count)| count)
            .map(|(&color, &count)| (color, count));

        Self {
            unique_colors: color_counts,
            total_pixels: binary_data.len(),
            most_common_color,
        }
    }

    #[allow(dead_code)]
    pub fn unique_color_count(&self) -> usize {
        self.unique_colors.len()
    }

    #[allow(dead_code)]
    pub fn color_usage_percent(&self, color: u8) -> f64 {
        if let Some(&count) = self.unique_colors.get(&color) {
            (count as f64 / self.total_pixels as f64) * 100.0
        } else {
            0.0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use image::{ImageBuffer, Rgb};

    #[test]
    fn test_rgb_to_esp32_color() {
        // Test pure colors
        assert_eq!(rgb_to_esp32_color(&Rgb([255, 255, 255])), 0xFF); // White: 11111111
        assert_eq!(rgb_to_esp32_color(&Rgb([0, 0, 0])), 0x00);       // Black: 00000000
        assert_eq!(rgb_to_esp32_color(&Rgb([255, 0, 0])), 0xE0);     // Red:   11100000
        assert_eq!(rgb_to_esp32_color(&Rgb([0, 255, 0])), 0x1C);     // Green: 00011100
        assert_eq!(rgb_to_esp32_color(&Rgb([0, 0, 255])), 0x03);     // Blue:  00000011
    }

    #[test]
    fn test_esp32_color_to_rgb() {
        // Test round-trip conversion (note: some precision is lost)
        let white_rgb = esp32_color_to_rgb(0xFF);
        assert_eq!(white_rgb, [255, 255, 255]);

        let black_rgb = esp32_color_to_rgb(0x00);
        assert_eq!(black_rgb, [0, 0, 0]);

        // Red should be approximately preserved
        let red_rgb = esp32_color_to_rgb(0xE0);
        assert!(red_rgb[0] > 200); // Should be close to 255
        assert!(red_rgb[1] < 50);  // Should be close to 0
        assert!(red_rgb[2] < 50);  // Should be close to 0
    }

    #[test]
    fn test_convert_to_esp32_binary() {
        // Create a small test image
        let img: RgbImage = ImageBuffer::new(2, 2);
        let binary_data = convert_to_esp32_binary(&img).unwrap();
        
        assert_eq!(binary_data.len(), 4); // 2x2 = 4 pixels
        
        // All pixels should be black (0x00) since we created an empty image
        assert!(binary_data.iter().all(|&b| b == 0x00));
    }

    #[test]
    fn test_validate_binary_size() {
        let data = vec![0u8; 100];
        
        // Valid size
        assert!(validate_binary_size(&data, 10, 10).is_ok());
        
        // Invalid size
        assert!(validate_binary_size(&data, 5, 5).is_err());
        assert!(validate_binary_size(&data, 20, 20).is_err());
    }

    #[test]
    fn test_color_stats() {
        let data = vec![0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xE0];
        let stats = ColorStats::analyze(&data);
        
        assert_eq!(stats.total_pixels, 6);
        assert_eq!(stats.unique_color_count(), 3);
        assert_eq!(stats.most_common_color, Some((0xFF, 3)));
        
        // Test percentages
        assert!((stats.color_usage_percent(0xFF) - 50.0).abs() < 0.1);
        assert!((stats.color_usage_percent(0x00) - 33.33).abs() < 0.1);
    }

    #[test]
    fn test_generate_c_header() {
        let data = vec![0x00, 0xFF, 0xE0, 0x1C];
        let header = generate_c_header(&data, "TEST_IMAGE", "test.bmp", 2, 2);
        
        assert!(header.contains("#ifndef _TEST_IMAGE_H_"));
        assert!(header.contains("const unsigned char TEST_IMAGE[4]"));
        assert!(header.contains("0x00, 0xFF"));
        assert!(header.contains("0xE0, 0x1C"));
        assert!(header.contains("Image dimensions: 2x2"));
    }
}